// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package minitec_db

import (
	"context"
	"database/sql"
)

const countStationsPerProject = `-- name: CountStationsPerProject :many
SELECT p.name, COUNT(s.id) as station_count
FROM Project p
LEFT JOIN Station s ON p.id = s.project_id
GROUP BY p.id
`

type CountStationsPerProjectRow struct {
	Name         string
	StationCount int64
}

// Count the number of stations per project
func (q *Queries) CountStationsPerProject(ctx context.Context) ([]CountStationsPerProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, countStationsPerProject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountStationsPerProjectRow
	for rows.Next() {
		var i CountStationsPerProjectRow
		if err := rows.Scan(&i.Name, &i.StationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createProject = `-- name: CreateProject :execresult
INSERT INTO Project (name, code)
VALUES (?, ?)
`

type CreateProjectParams struct {
	Name string
	Code string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProject, arg.Name, arg.Code)
}

const createState = `-- name: CreateState :execresult
INSERT INTO State (final_state, start_date, end_date, station_id)
VALUES (?, ?, ?, ?)
`

type CreateStateParams struct {
	FinalState sql.NullInt32
	StartDate  sql.NullTime
	EndDate    sql.NullTime
	StationID  int64
}

func (q *Queries) CreateState(ctx context.Context, arg CreateStateParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createState,
		arg.FinalState,
		arg.StartDate,
		arg.EndDate,
		arg.StationID,
	)
}

const createStation = `-- name: CreateStation :execresult
INSERT INTO Station (name, project_id)
VALUES (?, ?)
`

type CreateStationParams struct {
	Name      string
	ProjectID int64
}

func (q *Queries) CreateStation(ctx context.Context, arg CreateStationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createStation, arg.Name, arg.ProjectID)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO User (first_name, second_name, email, isAdmin, isBanned)
VALUES (?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	FirstName  string
	SecondName string
	Email      string
	Isadmin    bool
	Isbanned   bool
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.FirstName,
		arg.SecondName,
		arg.Email,
		arg.Isadmin,
		arg.Isbanned,
	)
}

const createUserProject = `-- name: CreateUserProject :execresult
INSERT INTO User_Project (user_id, project_id)
VALUES (?, ?)
`

type CreateUserProjectParams struct {
	UserID    int64
	ProjectID int64
}

func (q *Queries) CreateUserProject(ctx context.Context, arg CreateUserProjectParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserProject, arg.UserID, arg.ProjectID)
}

const deleteProject = `-- name: DeleteProject :execresult
DELETE FROM Project WHERE id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteProject, id)
}

const getActiveStationState = `-- name: GetActiveStationState :one
SELECT id, final_state, start_date, end_date, station_id FROM State
WHERE station_id = ? AND end_date IS NULL
`

// Find the current active state for a station (assuming null end_date means active)
func (q *Queries) GetActiveStationState(ctx context.Context, stationID int64) (State, error) {
	row := q.db.QueryRowContext(ctx, getActiveStationState, stationID)
	var i State
	err := row.Scan(
		&i.ID,
		&i.FinalState,
		&i.StartDate,
		&i.EndDate,
		&i.StationID,
	)
	return i, err
}

const getProject = `-- name: GetProject :one
SELECT id, name, code FROM Project WHERE id = ?
`

func (q *Queries) GetProject(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name, &i.Code)
	return i, err
}

const getState = `-- name: GetState :one
SELECT id, final_state, start_date, end_date, station_id FROM State WHERE id = ?
`

func (q *Queries) GetState(ctx context.Context, id int64) (State, error) {
	row := q.db.QueryRowContext(ctx, getState, id)
	var i State
	err := row.Scan(
		&i.ID,
		&i.FinalState,
		&i.StartDate,
		&i.EndDate,
		&i.StationID,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, first_name, second_name, email, isadmin, isbanned FROM User WHERE id = ?
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.SecondName,
		&i.Email,
		&i.Isadmin,
		&i.Isbanned,
	)
	return i, err
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, code FROM Project 
ORDER BY code 
LIMIT ? OFFSET ?
`

type ListProjectsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListProjects(ctx context.Context, arg ListProjectsParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(&i.ID, &i.Name, &i.Code); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsWithoutUsers = `-- name: ListProjectsWithoutUsers :many
SELECT p.name
FROM Project p
LEFT JOIN User_Project up ON p.id = up.project_id
WHERE up.user_id IS NULL
`

// Find projects that have no users assigned
func (q *Queries) ListProjectsWithoutUsers(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsWithoutUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationHistory = `-- name: ListStationHistory :many
SELECT st.final_state, st.start_date, st.end_date
FROM State st
WHERE st.station_id = ?
ORDER BY st.start_date DESC
`

type ListStationHistoryRow struct {
	FinalState sql.NullInt32
	StartDate  sql.NullTime
	EndDate    sql.NullTime
}

// Get the history of states for a specific station, ordered by start date
func (q *Queries) ListStationHistory(ctx context.Context, stationID int64) ([]ListStationHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listStationHistory, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStationHistoryRow
	for rows.Next() {
		var i ListStationHistoryRow
		if err := rows.Scan(&i.FinalState, &i.StartDate, &i.EndDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationsByProject = `-- name: ListStationsByProject :many
SELECT s.id, s.name, p.name as project_name
FROM Station s
JOIN Project p ON s.project_id = p.id
WHERE p.id = ?
`

type ListStationsByProjectRow struct {
	ID          int64
	Name        string
	ProjectName string
}

// Get all stations associated with a specific project
func (q *Queries) ListStationsByProject(ctx context.Context, id int64) ([]ListStationsByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listStationsByProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStationsByProjectRow
	for rows.Next() {
		var i ListStationsByProjectRow
		if err := rows.Scan(&i.ID, &i.Name, &i.ProjectName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, first_name, second_name, email, isadmin, isbanned FROM User
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.SecondName,
			&i.Email,
			&i.Isadmin,
			&i.Isbanned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByProject = `-- name: ListUsersByProject :many
SELECT u.first_name, u.second_name, u.email
FROM User u
JOIN User_Project up ON u.id = up.user_id
WHERE up.project_id = ?
`

type ListUsersByProjectRow struct {
	FirstName  string
	SecondName string
	Email      string
}

// List all users assigned to a specific project
func (q *Queries) ListUsersByProject(ctx context.Context, projectID int64) ([]ListUsersByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersByProjectRow
	for rows.Next() {
		var i ListUsersByProjectRow
		if err := rows.Scan(&i.FirstName, &i.SecondName, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
