// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package minitec_db

import (
	"context"
	"database/sql"
)

const createProject = `-- name: CreateProject :execresult
INSERT INTO Project (name, code)
VALUES (?, ?)
`

type CreateProjectParams struct {
	Name string
	Code string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProject, arg.Name, arg.Code)
}

const createState = `-- name: CreateState :execresult
INSERT INTO State (final_state, start_date, end_date, station_id)
VALUES (?, ?, ?, ?)
`

type CreateStateParams struct {
	FinalState int32
	StartDate  sql.NullTime
	EndDate    sql.NullTime
	StationID  int64
}

func (q *Queries) CreateState(ctx context.Context, arg CreateStateParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createState,
		arg.FinalState,
		arg.StartDate,
		arg.EndDate,
		arg.StationID,
	)
}

const createStation = `-- name: CreateStation :execresult
INSERT INTO Station (name, project_id)
VALUES (?, ?)
`

type CreateStationParams struct {
	Name      string
	ProjectID int64
}

func (q *Queries) CreateStation(ctx context.Context, arg CreateStationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createStation, arg.Name, arg.ProjectID)
}

const deleteProject = `-- name: DeleteProject :execresult
DELETE FROM Project WHERE id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteProject, id)
}

const getProject = `-- name: GetProject :one
SELECT id, name, code FROM Project WHERE id = ?
`

func (q *Queries) GetProject(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProject, id)
	var i Project
	err := row.Scan(&i.ID, &i.Name, &i.Code)
	return i, err
}

const getProjectByCode = `-- name: GetProjectByCode :one
SELECT id, name, code FROM Project WHERE code = ?
`

func (q *Queries) GetProjectByCode(ctx context.Context, code string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByCode, code)
	var i Project
	err := row.Scan(&i.ID, &i.Name, &i.Code)
	return i, err
}

const getState = `-- name: GetState :one
SELECT id, final_state, start_date, end_date, station_id FROM State WHERE id = ?
`

func (q *Queries) GetState(ctx context.Context, id int64) (State, error) {
	row := q.db.QueryRowContext(ctx, getState, id)
	var i State
	err := row.Scan(
		&i.ID,
		&i.FinalState,
		&i.StartDate,
		&i.EndDate,
		&i.StationID,
	)
	return i, err
}

const getStationId = `-- name: GetStationId :one
SELECT id FROM Station WHERE name = ? AND project_id = ?
`

type GetStationIdParams struct {
	Name      string
	ProjectID int64
}

func (q *Queries) GetStationId(ctx context.Context, arg GetStationIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStationId, arg.Name, arg.ProjectID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, code FROM Project 
ORDER BY code 
LIMIT ? OFFSET ?
`

type ListProjectsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListProjects(ctx context.Context, arg ListProjectsParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(&i.ID, &i.Name, &i.Code); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationsByProject = `-- name: ListStationsByProject :many
SELECT id, name, project_id FROM Station WHERE project_id = ?
`

// Get all stations associated with a specific project
func (q *Queries) ListStationsByProject(ctx context.Context, projectID int64) ([]Station, error) {
	rows, err := q.db.QueryContext(ctx, listStationsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Station
	for rows.Next() {
		var i Station
		if err := rows.Scan(&i.ID, &i.Name, &i.ProjectID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationsByStation = `-- name: ListStationsByStation :many
SELECT id, final_state, start_date, end_date, station_id FROM State WHERE station_id = ?
ORDER BY State.start_date ASC
`

// Get all states associated with a specific station
func (q *Queries) ListStationsByStation(ctx context.Context, stationID int64) ([]State, error) {
	rows, err := q.db.QueryContext(ctx, listStationsByStation, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []State
	for rows.Next() {
		var i State
		if err := rows.Scan(
			&i.ID,
			&i.FinalState,
			&i.StartDate,
			&i.EndDate,
			&i.StationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :exec
UPDATE Project
SET name = ?, code = ?
WHERE id = ?
`

type UpdateProjectParams struct {
	Name string
	Code string
	ID   int64
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateProject, arg.Name, arg.Code, arg.ID)
	return err
}
